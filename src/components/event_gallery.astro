---
// src/components/event_gallery.astro
// Composant pour afficher la galerie d'un événement avec swipe mobile

import { loadEventGallery } from '../utils/gallery';
import type { EventEntry } from '../../types';
import OptimizeImage from './optimize_image.astro';

export interface Props {
  event: EventEntry;
  maxThumbnails?: number;
}

const { 
  event, 
  maxThumbnails = 3 
} = Astro.props;

// Charger la galerie de l'événement
const gallery = await loadEventGallery(event.slug, event);

// Si pas de galerie, ne rien afficher
if (!gallery) {
  return null;
}

// Limiter les miniatures affichées
const thumbnails = gallery.photos.slice(0, maxThumbnails);

// Import des images pour récupérer les URLs optimisées
const images = import.meta.glob('/src/assets/galleries/**/*.{png,jpg,jpeg,webp,avif}', { 
  eager: true,
  import: 'default'
}) as Record<string, any>;

// Fonction pour obtenir l'URL réelle de l'image optimisée
function getOptimizedImageUrl(imagePath: string): string {
  const imageObj = images[imagePath];
  return imageObj?.src || imagePath;
}
---

{gallery && (
  <section class="event-gallery m-8">
    
    <div class="flex gap-3 overflow-x-auto pb-4">
      {thumbnails.map((photo, index) => (
        <div class="flex-none w-32">
          <button 
            class="gallery-trigger my-2 w-full h-32 block cursor-pointer hover:opacity-80 transition-opacity rounded-lg overflow-hidden bg-[color:rgba(var(--color-primary-rgb),0.05)]"
            data-gallery-id={event.slug}
            data-start-index={index}
            data-optimized-src={getOptimizedImageUrl(photo.src)}
            aria-label={`Voir la galerie de ${event.data.title}, photo ${index + 1}`}
          >
            <OptimizeImage
              src={photo.src}
              alt={photo.alt}
              class="w-full h-full object-cover"
              widths={[128, 256]}
              sizes="256px"
              loading="lazy"
            />
          </button>
        </div>
      ))}
      
      {gallery.photos.length > maxThumbnails && (
        <div class="flex-none w-32 h-32 flex items-center justify-center text-sm opacity-60 border border-dashed border-[var(--color-border)] rounded-lg">
          +{gallery.photos.length - maxThumbnails} photo{gallery.photos.length - maxThumbnails > 1 ? 's' : ''}
        </div>
      )}
    </div>

    <!-- Modal galerie intégrée -->
    <div 
      id={`gallery-modal-${event.slug}`}
      class="gallery-modal rounded-xl border border-[var(--color-border)] overflow-hidden max-w-[95vw] max-h-[95vh]" 
      popover
      tabindex="-1"
    >
      <!-- Header avec info et bouton fermer -->
      <div class="bg-[var(--color-secondary)] text-white p-3 flex justify-between items-center">
        <div>
          <h3 class="font-medium" style="color: white;">{event.data.title}</h3>
          <p class="text-sm opacity-90">Par {gallery.photographer}</p>
        </div>
        <button 
          class="w-7 h-7 bg-white/20 hover:bg-white/30 rounded-full flex items-center justify-center transition-colors"
          popovertarget={`gallery-modal-${event.slug}`}
          aria-label="Fermer"
        >
          <svg width="12" height="12" viewBox="0 0 12 12" fill="currentColor">
            <path d="M1 1L11 11M11 1L1 11" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
          </svg>
        </button>
      </div>
      
      <!-- Zone image avec swipe et navigation invisible -->
      <div class="gallery-viewer bg-black relative min-h-[70vh] touch-pan-x">
        <img
          id={`gallery-current-${event.slug}`}
          class="max-w-full max-h-[70vh] object-contain w-auto h-auto absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2"
          alt=""
          loading="lazy"
        />
        
        <!-- Zone tactile gauche (invisible mais cliquable) -->
        <button 
          id={`gallery-prev-${event.slug}`}
          class="gallery-nav-zone absolute left-0 top-0 w-1/5 h-full z-10 opacity-0 flex items-center justify-start pl-4 md:opacity-100 md:w-10 md:h-10 md:left-4 md:top-1/2 md:-translate-y-1/2 md:justify-center md:pl-0 md:rounded-full hover:opacity-80 disabled:opacity-40 disabled:cursor-not-allowed"
          style="background-color: transparent; color: white; border: none;"
          aria-label="Image précédente"
        >
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="15 18 9 12 15 6"></polyline>
          </svg>
        </button>
        
        <!-- Zone tactile droite (invisible mais cliquable) -->
        <button 
          id={`gallery-next-${event.slug}`}
          class="gallery-nav-zone absolute right-0 top-0 w-1/5 h-full z-10 opacity-0 flex items-center justify-end pr-4 md:opacity-100 md:w-10 md:h-10 md:right-4 md:top-1/2 md:-translate-y-1/2 md:justify-center md:pr-0 md:rounded-full hover:opacity-80 disabled:opacity-40 disabled:cursor-not-allowed"
          style="background-color: transparent; color: white; border: none;"
          aria-label="Image suivante"
        >
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="9 18 15 12 9 6"></polyline>
          </svg>
        </button>
      </div>
      
      <!-- Barre de miniatures horizontale -->
      <div class="p-3 bg-[var(--bg-color)] border-t border-[var(--color-border)]">
        <div class="flex gap-2 overflow-x-auto pb-2">
          {gallery.photos.map((photo, index) => (
            <button 
              class="gallery-thumb flex-none w-16 h-12 rounded overflow-hidden border-2 border-transparent hover:border-[var(--color-primary)] transition-colors"
              data-index={index}
              data-optimized-src={getOptimizedImageUrl(photo.src)}
              aria-label={`Voir photo ${index + 1}`}
            >
              <OptimizeImage
                src={photo.src}
                alt={photo.alt}
                class="w-full h-full object-cover"
                widths={[64, 128]}
                sizes="64px"
                loading="lazy"
              />
            </button>
          ))}
        </div>
      </div>
    </div>
  </section>
)}

<style>
  /* Styles de centrage avec positionnement plus haut */
  .gallery-modal {
    position: fixed;
    top: 25%;
    left: 50%;
    transform: translate(-50%, -25%) scale(0.8);
    margin: 0;
    opacity: 0;
    transition: 
      display 0.3s allow-discrete,
      opacity 0.3s ease,
      transform 0.3s ease;
    transition-behavior: allow-discrete;
  }

  .gallery-modal:popover-open {
    opacity: 1;
    transform: translate(-50%, -25%) scale(1);
    
    @starting-style {
      opacity: 0;
      transform: translate(-50%, -25%) scale(0.8);
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .gallery-modal {
      transition: display 0.3s allow-discrete, opacity 0.3s ease;
      transform: translate(-50%, -25%) scale(1);
    }
    
    .gallery-modal:popover-open {
      transform: translate(-50%, -25%) scale(1);
    }
  }
  
  /* Style pour miniature active */
  .gallery-thumb.active {
    border-color: var(--color-primary);
  }

  /* Styles pour les zones de navigation mobile */
  .gallery-nav-zone {
    border: none;
    cursor: pointer;
  }

  /* Desktop : fond de couleur pour les boutons */
  @media (min-width: 768px) {
    .gallery-nav-zone {
      background-color: var(--color-secondary) !important;
    }
  }

  /* Mobile : cacher complètement les boutons disabled */
  @media (max-width: 767px) {
    .gallery-nav-zone:disabled {
      display: none;
    }
  }

  /* Zone tactile avec feedback visuel discret au touch */
  .gallery-nav-zone:active {
    background-color: rgba(255, 255, 255, 0.1);
  }

  /* Support du swipe */
  .gallery-viewer {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
  }
</style>

<script>
  // Script pour gérer les galeries d'événements avec support swipe
  function initEventGalleries() {
    document.querySelectorAll('[data-gallery-id]').forEach(trigger => {
      const galleryId = trigger.getAttribute('data-gallery-id');
      if (!galleryId) return;

      const modal = document.getElementById(`gallery-modal-${galleryId}`);
      const currentImage = document.getElementById(`gallery-current-${galleryId}`) as HTMLImageElement;
      const prevBtn = document.getElementById(`gallery-prev-${galleryId}`);
      const nextBtn = document.getElementById(`gallery-next-${galleryId}`);
      const galleryViewer = modal?.querySelector('.gallery-viewer');
      
      if (!modal || !currentImage || !prevBtn || !nextBtn || !galleryViewer) return;

      // Récupérer toutes les images de cette galerie depuis les miniatures
      const thumbs = modal.querySelectorAll('.gallery-thumb');
      const galleryData = Array.from(thumbs).map(thumb => ({
        src: thumb.getAttribute('data-optimized-src') || '',
        alt: thumb.querySelector('img')?.alt || ''
      }));

      let currentIndex = 0;
      
      // Variables pour le swipe
      let startX = 0;
      let startY = 0;
      let isSwipeStarted = false;

      // Fonction pour mettre à jour l'affichage
      function updateDisplay() {
        const item = galleryData[currentIndex];
        if (item && item.src) {
          currentImage.src = item.src;
          currentImage.alt = item.alt;
          
          // Mettre à jour les boutons de navigation
          (prevBtn as HTMLButtonElement).disabled = currentIndex === 0;
          (nextBtn as HTMLButtonElement).disabled = currentIndex === galleryData.length - 1;
          
          // Mettre à jour les miniatures actives
          thumbs.forEach((thumb, index) => {
            thumb.classList.toggle('active', index === currentIndex);
          });
        }
      }

      // Navigation functions
      function goToPrev() {
        if (currentIndex > 0) {
          currentIndex--;
          updateDisplay();
        }
      }

      function goToNext() {
        if (currentIndex < galleryData.length - 1) {
          currentIndex++;
          updateDisplay();
        }
      }

      // Ouvrir la galerie depuis le trigger principal
      trigger.addEventListener('click', (e) => {
        e.preventDefault();
        const startIndex = parseInt(trigger.getAttribute('data-start-index') || '0');
        currentIndex = startIndex;
        updateDisplay();
        (modal as any).showPopover();
        
        setTimeout(() => modal.focus(), 100);
      });

      // Navigation boutons
      prevBtn.addEventListener('click', goToPrev);
      nextBtn.addEventListener('click', goToNext);

      // Navigation par miniatures
      thumbs.forEach((thumb, index) => {
        thumb.addEventListener('click', () => {
          currentIndex = index;
          updateDisplay();
        });
      });

      // Navigation clavier
      modal.addEventListener('keydown', (e: KeyboardEvent) => {
        if (e.key === 'ArrowLeft') {
          goToPrev();
        } else if (e.key === 'ArrowRight') {
          goToNext();
        }
      });

      // Gestion du swipe - approche KISS avec gestion améliorée des conflits
      galleryViewer.addEventListener('touchstart', (e) => {
        const touch = (e as TouchEvent).touches[0];
        startX = touch.clientX;
        startY = touch.clientY;
        isSwipeStarted = true;
      }, { passive: true });

      galleryViewer.addEventListener('touchmove', (e) => {
        if (!isSwipeStarted) return;
        
        const touch = (e as TouchEvent).touches[0];
        const deltaX = touch.clientX - startX;
        const deltaY = touch.clientY - startY;
        
        // Si mouvement horizontal significatif, empêcher le scroll
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 20) {
          e.preventDefault();
        }
      }, { passive: false });

      galleryViewer.addEventListener('touchend', (e) => {
        if (!isSwipeStarted) return;
        
        const touch = (e as TouchEvent).changedTouches[0];
        const endX = touch.clientX;
        const endY = touch.clientY;
        
        const deltaX = endX - startX;
        const deltaY = endY - startY;
        
        // Vérifier que c'est bien un swipe horizontal
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
          if (deltaX > 0) {
            // Swipe vers la droite = image précédente
            goToPrev();
          } else {
            // Swipe vers la gauche = image suivante
            goToNext();
          }
        }
        
        isSwipeStarted = false;
      }, { passive: true });

      galleryViewer.addEventListener('touchcancel', () => {
        isSwipeStarted = false;
      }, { passive: true });
    });
  }

  // Initialiser au chargement et lors des transitions Astro
  document.addEventListener('DOMContentLoaded', initEventGalleries);
  document.addEventListener('astro:page-load', initEventGalleries);
  
  // Initialiser immédiatement si déjà chargé
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initEventGalleries);
  } else {
    initEventGalleries();
  }
</script>